{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is CocosAI","text":"<p>CocosAI (Confidential Computing System for AI) is a SW system for enabling confidential and privacy-preserving AI/ML, i.e. execution of model training and algorithm inference on confidential data sets. Privacy-preservation is considered a \u201choly grail\u201d of AI. It opens many possibilities, among which is a collaborative, trustworthy AI.</p> <p>CocosAI leverages Confidential Computing, a novel paradigm based on specialized HW CPU extensions for producting secure encrypted enclaves in memory (Trusted Execution Enviroments, or TEEs), thus isolating confidential data and programs from the rest of the SW running on the host.</p> <p>The final product enables data scientists to train AI and ML models on confidential data that is never revealed, and can be used for Secure Multi-Party Computation (SMPC). AI/ML on combined data sets that come from different sources will unlock huge value.</p> <p></p>"},{"location":"#features","title":"Features","text":"<p>CoCoS.ai is enabling the following features:</p> <ul> <li>TEE enablement, deployment and monitoring</li> <li>In-enclave agent, networking controller and other system software</li> <li>Encrypted asynchronous data transfer and result delivery</li> <li>API for programmable platform manipulation</li> <li>HW and SW supported attestation with verification tools</li> <li>CLI for system interaction</li> </ul>"},{"location":"#license","title":"License","text":"<p>CocosAI is published under liberal Apache-2.0 open-source license.</p>"},{"location":"#github","title":"GitHub","text":"<p>CocosAI can be downloaded from its GitHub repository</p>"},{"location":"agent/","title":"Agent","text":"<p>The agent is responsible for the life cycle of the computation, i.e., running the computation and sending events about the status of the computation within the TEE. The agent is found inside the VM (TEE), and each computation within the TEE has its own agent. When a computation run request is sent from the manager, manager creates a VM where the agent is found and sends the computation manifest to the agent.</p> <p>The picture below shows where the agent runs in the Cocos system, helping us better understand its role.</p> <p></p>"},{"location":"agent/#statemachine","title":"StateMachine","text":"<ul> <li>Orchestrates the overall flow of the computation.</li> <li>Transitions between states based on received events.</li> <li>Defines valid state transitions and associated functions.</li> </ul>"},{"location":"agent/#states","title":"States","text":"<ul> <li><code>idle</code>: Initial state, waiting for the computation to start.</li> <li><code>receivingManifest</code>: Receives the initial computation manifest.</li> <li><code>receivingAlgorithm</code>: Receives the algorithm for the computation.</li> <li><code>receivingData</code>: Receives dataset data for the computation.</li> <li><code>running</code>: Executes the computation using received algorithms and data.</li> <li><code>resultsReady</code>: Computation has finished, results are available.</li> <li><code>complete</code>: All results have been consumed, computation lifecycle ends.</li> </ul>"},{"location":"agent/#events","title":"Events","text":"<ul> <li><code>start</code>: Triggers the computation startup process.</li> <li><code>manifestReceived</code>: Indicates computation manifest has been received.</li> <li><code>algorithmReceived</code>: Indicates the algorithm has been received.</li> <li><code>dataReceived</code>: Indicates all dataset data has been received.</li> <li><code>runComplete</code>: Signals the completion of the computation execution.</li> <li><code>resultsConsumed</code>: Indicates all consumers have retrieved the results.</li> </ul>"},{"location":"agent/#agent-events","title":"Agent Events","text":"<p>As the computation in the agent undergoes different operations, it sends events to the manager so that the user can monitor the computation from either the UI or other client. Events sent to the manager are based on the agent state as defined by the statemachine.</p>"},{"location":"agent/#vsock-connection-between-agent-manager","title":"Vsock Connection Between Agent &amp; Manager","text":"<p>Agent sends agent events and logs to the manager via vsock. The manager listens to the vsock and forwards the events via gRPC. The agent events and logs are used to show the status of the computation inside the TEE so that a user can be aware of what is happening inside the TEE.</p>"},{"location":"agent/#attestation","title":"Attestation","text":"<p>The agent can fetch the attestation report from the host using the AMD SEV guest driver. The attestation report proves that the agent is running inside the secure virtual machine (SVM) and that the SVM is running the expected code on the expected hardware and is configured correctly.</p>"},{"location":"agent/#algorithm-and-dataset-validation","title":"Algorithm and dataset validation","text":"<p>Before execution, algorithms and datasets are validated against the computation manifest to ensure integrity and compatibility. This includes the sha3 256 hash of the dataset and algorithm, which are validated against the value set in the manifest. The algorithm and dataset provider ID are also validated against the manifest during the uploading of the dataset and algorithm.</p>"},{"location":"agent/#supported-algorithm-types","title":"Supported Algorithm types","text":"<p>There are four supported algorithm types, binaries, python files, docker images and wasm modules. The default algorithm type is binaries, which is uploaded to agent using CLI. Instructions on how to provide a python file are provided in CLI. More information on how to run the other types of algorithms can be found here.</p>"},{"location":"algorithms/","title":"Algorithms","text":"<p>Currently, cocos supports running the following algorithms:</p> <ul> <li>binary algorithms</li> <li>python scripts</li> <li>docker images</li> <li>wasm modules</li> </ul>"},{"location":"algorithms/#binary-algorithms","title":"Binary Algorithms","text":"<p>Binary algorithms are compiled to run on the enclave. The enclave is a secure environment that runs on the host machine. The enclave is created by the manager and the agent is loaded into the enclave. The agent is responsible for running the computation and communicating with the outside world.</p>"},{"location":"algorithms/#running-binary-algorithms","title":"Running Binary Algorithms","text":"<p>For Binary algorithms, with datatsets or without datasets the process is similar to all the other algorithms.</p> <p>NOTE: Make sure you have terminated the previous computation before starting a new one.</p>"},{"location":"algorithms/#download-examples","title":"Download Examples","text":"<p>Download the examples from the AI repository and follow the instructions in the README file to compile one of the examples.</p> <pre><code>git clone https://github.com/ultravioletrs/ai\n</code></pre>"},{"location":"algorithms/#build-addition-example","title":"Build Addition example","text":"<p>Make sure you have Rust installed. If not, you can install it by following the instructions here.</p> <pre><code>cd ai/burn-algorithms\n</code></pre> <p>NOTE: Make sure you have rust installed. If not, you can install it by following the instructions here.</p> <pre><code>cargo build --release --bin addition --features cocos\n</code></pre> <p>This will generate the binary in the <code>target/release</code> folder. Copy the binary to the <code>cocos</code> folder.</p> <pre><code>cp target/release/addition ../../cocos/\n</code></pre> <p>Start the computation server:</p> <pre><code>go run ./test/computations/main.go ./addition public.pem false\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>{\"time\":\"2024-08-19T14:09:28.852409931+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n</code></pre> <p>Start the manager</p> <pre><code>sudo \\\nMANAGER_QEMU_SMP_MAXCPUS=4 \\\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_ENABLE_SEV_SNP=false \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/x64/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/x64/OVMF_VARS.fd \\\ngo run main.go\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>{\"time\":\"2024-08-19T14:10:00.239331599+03:00\",\"level\":\"INFO\",\"msg\":\"-enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=4 -m 2048M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/edk2/x64/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=/usr/share/edk2/x64/OVMF_VARS.fd -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,addr=0x2,romfile= -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 -vnc :0 -kernel img/bzImage -append \\\"earlyprintk=serial console=ttyS0\\\" -initrd img/rootfs.cpio.gz -nographic -monitor pty\"}\n{\"time\":\"2024-08-19T14:10:17.798497671+03:00\",\"level\":\"INFO\",\"msg\":\"Method Run for computation took 17.438247421s to complete\"}\n{\"time\":\"2024-08-19T14:10:17.800162858+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: receivingManifest -&gt; receivingManifest\\\\n\\\"  computation_id:\\\"1\\\"  level:\\\"DEBUG\\\"  timestamp:{seconds:1724065817  nanos:796771386}}\"}\n{\"time\":\"2024-08-19T14:10:17.800336232+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: receivingAlgorithm -&gt; receivingAlgorithm\\\\n\\\"  computation_id:\\\"1\\\"  level:\\\"DEBUG\\\"  timestamp:{seconds:1724065817  nanos:797222579}}\"}\n{\"time\":\"2024-08-19T14:10:17.80043386+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"receivingAlgorithm\\\"  timestamp:{seconds:1724065817  nanos:797263757}  computation_id:\\\"1\\\"  originator:\\\"agent\\\" status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-08-19T14:10:17.8005587+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"agent service gRPC server listening at :7002 without TLS\\\"  computation_id:\\\"1\\\"  level:\\\"INFO\\\"  timestamp:{seconds:1724065817  nanos:797467753}}\"}\n2024/08/19 14:10:20 traces export: Post \"http://localhost:4318/v1/traces\": dial tcp [::1]:4318: connect: connection refused\n</code></pre> <p>The logs from the computation server will be similar to this:</p> <pre><code>{\"time\":\"2024-08-19T14:09:28.852409931+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n{\"time\":\"2024-08-19T14:10:00.354929002+03:00\",\"level\":\"DEBUG\",\"msg\":\"received who am on ip address [::1]:57968\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1724065800 nanos:360232336} computation_id:\"1\" originator:\"manager\" status:\"starting\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1724065800 nanos:360990806} computation_id:\"1\" originator:\"manager\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"char device redirected to /dev/pts/9 (label compat_monitor0)\\n\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1724065800 nanos:403232551}}\nreceived agent log\n&amp;{message:\"\\x1b[2J\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1724065801 nanos:103436975}}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1724065817 nanos:798465068} computation_id:\"1\" originator:\"manager\" status:\"complete\"}\nreceived runRes\n&amp;{agent_port:\"6050\" computation_id:\"1\"}\nreceived agent log\n&amp;{message:\"Transition: receivingManifest -&gt; receivingManifest\\n\" computation_id: \"1\" level:\"DEBUG\" timestamp:{seconds:1724065817 nanos:796771386}}\nreceived agent log\n&amp;{message:\"Transition: receivingAlgorithm -&gt; receivingAlgorithm\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1724065817 nanos:797222579}}\nreceived agent event\n&amp;{event_type:\"receivingAlgorithm\" timestamp:{seconds:1724065817 nanos:797263757} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"agent service gRPC server listening at :7002 without TLS\" computation_id:\"1\" level:\"INFO\" timestamp:{seconds:1724065817 nanos:797467753}}\n</code></pre> <p>Export the agent grpc url</p> <pre><code>export AGENT_GRPC_URL=localhost:6050\n</code></pre> <p>Upload the algorithm</p> <pre><code>./build/cocos-cli algo ./addition ./private.pem\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>2024/08/19 14:14:10 Uploading algorithm binary: ./addition\nUploading algorithm...  100% [===============================================&gt;]\n2024/08/19 14:14:10 Successfully uploaded algorithm\n</code></pre> <p>Since the algorithm is a binary, we don't need to upload the requirements file. Also, this is the addition example so we don't need to upload the dataset.</p> <p>Finally, download the results</p> <pre><code>./build/cocos-cli result ./private.pem\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>2024/08/19 14:14:31 Retrieving computation result file\n2024/08/19 14:14:31 Computation result retrieved and saved successfully!\n</code></pre> <p>Unzip the results</p> <pre><code>unzip result.zip -d results\n</code></pre> <pre><code>cat results/results.txt\n</code></pre> <p>The output will be similar to this:</p> <pre><code>\"[5.141593, 4.0, 5.0, 8.141593]\"\n</code></pre> <p>Terminal recording session</p> <p></p> <p>For real-world examples to test with cocos, see our AI repository.</p>"},{"location":"algorithms/#running-binary-algorithms-with-datasets","title":"Running Binary Algorithms With Datasets","text":"<p>NOTE: Make sure you have terminated the previous computation before starting a new one.</p>"},{"location":"algorithms/#build-iris-prediction-example","title":"Build Iris Prediction example","text":"<p>Make sure you have Rust installed. If not, you can install it by following the instructions here.</p> <pre><code>cd ai/burn-algorithms\n</code></pre> <p>NOTE: Make sure you have rust installed. If not, you can install it by following the instructions here.</p> <pre><code>cargo build --release --bin iris --features cocos\n</code></pre> <p>This will generate the binary in the <code>target/release</code> folder. Copy the binary to the <code>cocos</code> folder.</p> <pre><code>cp target/release/iris ../../cocos/\n</code></pre> <p>Copy the dataset to the <code>cocos</code> folder.</p> <pre><code>cp iris/data/Iris.csv ../../cocos\n</code></pre> <p>Start the computation server:</p> <pre><code>go run ./test/computations/main.go ./iris public.pem false ./Iris.csv\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>{\"time\":\"2024-08-19T14:26:11.446590856+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n</code></pre> <p>Start the manager</p> <pre><code>sudo \\\nMANAGER_QEMU_SMP_MAXCPUS=4 \\\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_ENABLE_SEV_SNP=false \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/x64/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/x64/OVMF_VARS.fd \\\ngo run main.go\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>{\"time\":\"2024-08-19T14:26:20.869571321+03:00\",\"level\":\"INFO\",\"msg\":\"-enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=4 -m 2048M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/edk2/x64/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=/usr/share/edk2/x64/OVMF_VARS.fd -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,addr=0x2,romfile= -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 -vnc :0 -kernel img/bzImage -append \\\"earlyprintk=serial console=ttyS0\\\" -initrd img/rootfs.cpio.gz -nographic -monitor pty\"}\n{\"time\":\"2024-08-19T14:26:39.096019489+03:00\",\"level\":\"INFO\",\"msg\":\"Method Run for computation took 18.206099301s to complete\"}\n{\"time\":\"2024-08-19T14:26:39.097590785+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: receivingManifest -&gt; receivingManifest\\\\n\\\"  computation_id:\\\"1\\\"  level:\\\"DEBUG\\\"  timestamp:{seconds:1724066799  nanos:94341079}}\"}\n{\"time\":\"2024-08-19T14:26:39.097907318+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"receivingAlgorithm\\\"  timestamp:{seconds:1724066799  nanos:94599012}  computation_id:\\\"1\\\"  originator:\\\"agent\\\"  status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-08-19T14:26:39.097933878+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"agent service gRPC server listening at :7002 without TLS\\\"  computation_id:\\\"1\\\"  level:\\\"INFO\\\"  timestamp:{seconds:1724066799  nanos:94831037}}\"}\n2024/08/19 14:26:40 traces export: Post \"http://localhost:4318/v1/traces\": dial tcp [::1]:4318: connect: connection refused\n</code></pre> <p>The logs from the computation server will be similar to this:</p> <pre><code>{\"time\":\"2024-08-19T14:26:11.446590856+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n{\"time\":\"2024-08-19T14:26:20.871605244+03:00\",\"level\":\"DEBUG\",\"msg\":\"received who am on ip address [::1]:47994\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1724066780 nanos:889897585} computation_id:\"1\" originator:\"manager\" status:\"starting\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1724066780 nanos:891441319} computation_id:\"1\" originator:\"manager\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"char device redirected to /dev/pts/8 (label compat_monitor0)\\n\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1724066780 nanos:935158505}}\nreceived agent log\n&amp;{message:\"\\x1b[2\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1724066781 nanos:414565103}}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1724066799 nanos:95970587} computation_id:\"1\" originator:\"manager\" status:\"complete\"}\nreceived runRes\n&amp;{agent_port:\"6014\" computation_id:\"1\"}\nreceived agent log\n&amp;{message:\"Transition: receivingManifest -&gt; receivingManifest\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1724066799 nanos:94341079}}\nreceived agent event\n&amp;{event_type:\"receivingAlgorithm\" timestamp:{seconds:1724066799 nanos:94599012} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"agent service gRPC server listening at :7002 without TLS\" computation_id:\"1\" level:\"INFO\" timestamp:{seconds:1724066799 nanos:94831037}}\n</code></pre> <p>Export the agent grpc url</p> <pre><code>export AGENT_GRPC_URL=localhost:6014\n</code></pre> <p>Upload the algorithm</p> <pre><code>./build/cocos-cli algo ./iris ./private.pem\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>2024/08/19 14:29:58 Uploading algorithm binary: ./iris\nUploading algorithm...  100% [===============================================&gt;]\n2024/08/19 14:29:58 Successfully uploaded algorithm\n</code></pre> <p>Upload the dataset</p> <pre><code>./build/cocos-cli data ./Iris.csv ./private.pem\n</code></pre> <pre><code>2024/08/19 14:30:55 Uploading dataset CSV: ./Iris.csv\nUploading data...  100% [====================================================&gt;]\n2024/08/19 14:30:55 Successfully uploaded dataset\n</code></pre> <p>Finally, download the results</p> <pre><code>./build/cocos-cli result ./private.pem\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>2024/08/19 14:31:46 Retrieving computation result file\n2024/08/19 14:31:46 Computation result retrieved and saved successfully!\n</code></pre> <p>Unzip the results</p> <pre><code>unzip result.zip -d results\n</code></pre> <p>Build the iris example from the AI repository</p> <pre><code>cd ../ai/burn-algorithms/\n</code></pre> <p>If you haven't already, create the artifacts folder</p> <pre><code>mkdir -p artifacts/iris\n</code></pre> <p>Copy the results to the artifacts folder</p> <pre><code>cp -r ../../cocos/results/* artifacts/iris/\n</code></pre> <p>Build the iris-inference example</p> <pre><code>cargo build --release --bin iris-inference\n</code></pre> <p>Test the iris-inference example</p> <pre><code>./target/release/iris-inference '{\"sepal_length\": 7.0, \"sepal_width\": 3.2, \"petal_length\": 4.7, \"petal_width\": 1.4}'\n</code></pre> <p>The output will be similar to this:</p> <pre><code>Iris-versicolor\n</code></pre> <p>Terminal recording session</p> <p></p> <p>For real-world examples to test with cocos, see our AI repository.</p>"},{"location":"algorithms/#python-scripts","title":"Python Scripts","text":"<p>Python is a high-level, interpreted programming language. Python scripts can be run on the enclave. Python is known for its simplicity and readability, making it a popular choice for beginners and experienced developers alike.</p>"},{"location":"algorithms/#running-python-algorithms-without-datasets","title":"Running Python Algorithms without Datasets","text":"<p>This has been covered in the previous section.</p>"},{"location":"algorithms/#running-python-algorithms-with-datasets","title":"Running Python Algorithms with Datasets","text":"<p>For Python algorithms, with datatsets:</p> <p>NOTE: Make sure you have terminated the previous computation before starting a new one.</p> <p>Start the computation server:</p> <pre><code>go run ./test/computations/main.go ./test/manual/algo/lin_reg.py public.pem false ./test/manual/data/iris.csv\n</code></pre> <p>Start the manager</p> <pre><code>sudo \\\nMANAGER_QEMU_SMP_MAXCPUS=4 \\\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_ENABLE_SEV_SNP=false \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/x64/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/x64/OVMF_VARS.fd \\\ngo run main.go\n</code></pre> <p>Export the agent grpc url from computation server logs, by default port 6100 will be allocated. If the port is not available, a different (random) port will be allocated, within the range 6100 - 6200. The port will be indicated on the computation server logs.</p> <pre><code>export AGENT_GRPC_URL=localhost:6100\n</code></pre> <p>Upload the algorithm</p> <pre><code>./build/cocos-cli algo ./test/manual/algo/lin_reg.py ./private.pem -a python -r ./test/manual/algo/requirements.txt\n</code></pre> <p>We pass the requirements file to the algorithm since it has dependencies.</p> <p>Upload the dataset</p> <pre><code>./build/cocos-cli data ./test/manual/data/iris.csv ./private.pem\n</code></pre> <p>Watch the agent logs until the computation is complete. The computation will take a while to complete since it will download the dependencies and run the algorithm.</p> <pre><code>&amp;{event_type:\"algorithm-run\" timestamp:{seconds:1723411516 nanos:935138750} computation_id:\"1\" originator:\"agent\" status:\"error\"}\nreceived agent event\n&amp;{event_type:\"resultsReady\" timestamp:{seconds:1723411517 nanos:882446542} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"Transition: resultsReady -&gt; resultsReady\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1723411517 nanos:882432675}}\n</code></pre> <p>Finally, download the results</p> <pre><code>./build/cocos-cli result ./private.pem\n</code></pre> <p>Unzip the results</p> <pre><code>unzip result.zip -d results\n</code></pre> <p>To read the results make sure you have installed the required dependencies from the requirements file. This should be done inside a virtual environment.</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npip install -r test/manual/algo/requirements.txt\n</code></pre> <pre><code>python3 test/manual/algo/lin_reg.py predict results/model.bin  test/manual/data/\n</code></pre> <p>The output will be similar to this:</p> <pre><code>Precision, Recall, Confusion matrix, in training\n\n                 precision    recall  f1-score   support\n\n    Iris-setosa      1.000     1.000     1.000        21\nIris-versicolor      0.923     0.889     0.906        27\n Iris-virginica      0.893     0.926     0.909        27\n\n       accuracy                          0.933        75\n      macro avg      0.939     0.938     0.938        75\n   weighted avg      0.934     0.933     0.933        75\n\n[[21  0  0]\n [ 0 24  3]\n [ 0  2 25]]\nPrecision, Recall, and Confusion matrix, in testing\n\n                 precision    recall  f1-score   support\n\n    Iris-setosa      1.000     1.000     1.000        29\nIris-versicolor      1.000     1.000     1.000        23\n Iris-virginica      1.000     1.000     1.000        23\n\n       accuracy                          1.000        75\n      macro avg      1.000     1.000     1.000        75\n   weighted avg      1.000     1.000     1.000        75\n\n[[29  0  0]\n [ 0 23  0]\n [ 0  0 23]]\n</code></pre> <p>Terminal recording session</p> <p></p> <p>For real-world examples to test with cocos, see our AI repository.</p>"},{"location":"algorithms/#running-algorithms-with-arguments","title":"Running Algorithms with arguments","text":"<p>To run an algorithm that requires command line arguments, you can append the algo command on cli with the arguments needed as shown in the addition example, which we will run with args below:</p> <p>NOTE: Make sure you have terminated the previous computation before starting a new one.</p> <p>Start the computation server:</p> <pre><code>go run ./test/computations/main.go ./test/manual/algo/addition.py public.pem false\n</code></pre> <p>Start the manager</p> <pre><code>sudo \\\nMANAGER_QEMU_SMP_MAXCPUS=4 \\\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_ENABLE_SEV_SNP=false \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/x64/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/x64/OVMF_VARS.fd \\\ngo run main.go\n</code></pre> <p>Export the agent grpc url from computation server logs, by default port 6100 will be allocated. If the port is not available, a different (random) port will be allocated, within the range 6100 - 6200. The port will be indicated on the computation server logs.</p> <pre><code>export AGENT_GRPC_URL=localhost:6100\n</code></pre> <p>Upload the algorithm</p> <pre><code>./build/cocos-cli algo ./test/manual/algo/addition.py ./private.pem -a python --args=\"--a\" --args=\"100\" --args=\"--b\" --args=\"20\"\n</code></pre> <p>The order and args of the algorithm should be as they are required by the algorithm. In the addition example, for instance, the args are set in order of how they are expected:</p> <pre><code>python3 addition.py --a 100 --b 200\n</code></pre> <p>Watch the agent logs until the computation is complete.</p> <pre><code>&amp;{event_type:\"algorithm-run\" timestamp:{seconds:1723411516 nanos:935138750} computation_id:\"1\" originator:\"agent\" status:\"error\"}\nreceived agent event\n&amp;{event_type:\"resultsReady\" timestamp:{seconds:1723411517 nanos:882446542} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"Transition: resultsReady -&gt; resultsReady\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1723411517 nanos:882432675}}\n</code></pre> <p>Finally, download the results</p> <pre><code>./build/cocos-cli result ./private.pem\n</code></pre>"},{"location":"algorithms/#docker","title":"Docker","text":"<p>Docker is a platform designed to build, share, and run containerized applications. A container packages the application code, runtime, system tools, libraries, and all necessary settings into a single unit. This ensures the container can be reliably transferred between different computing environments and be executed as expected.</p>"},{"location":"algorithms/#building-the-docker-image","title":"Building The Docker Image","text":"<p>The Docker images that the Agent will run inside the SVM must have some restrictions. The image must have a <code>/cocos</code> directory containing the <code>datasets</code> and <code>results</code> directories. The Agent will run this image inside the SVM and mount the <code>datasets</code> and <code>results</code> onto the\u00a0<code>/cocos/datasets</code>\u00a0and\u00a0<code>/cocos/results</code>\u00a0directories inside the image. The docker image must also contain the command that will be run when the docker container is run.</p> <p>We will use the linear regression example from the cocos repository in this example.</p> <pre><code>git clone https://github.com/ultravioletrs/cocos.git\n</code></pre> <p>Change directory to the linear regression example.</p> <pre><code>cd cocos/test/manual/algo/\n</code></pre> <p>Next, run the build command and save the docker image as a\u00a0<code>tar</code>\u00a0file. This example Dockerfile is based of the python linear regression example using iris dataset.</p> <pre><code>docker build -t linreg .\ndocker save linreg &gt; linreg.tar\n</code></pre>"},{"location":"algorithms/#running-docker-in-svm","title":"Running Docker in SVM","text":"<p>Change the current working directory to <code>cocos</code>.</p> <pre><code>cd ./cocos\n</code></pre> <p>Start the computation server:</p> <pre><code>go run ./test/computations/main.go ./test/manual/algo/linreg.tar public.pem false ./test/manual/data/iris.csv\n</code></pre> <p>Start the manager</p> <pre><code>cd cmd/manager\n</code></pre> <pre><code>sudo \\\nMANAGER_QEMU_SMP_MAXCPUS=4 \\\nMANAGER_QEMU_MEMORY_SIZE=25G \\\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_ENABLE_SEV_SNP=false \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/x64/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/x64/OVMF_VARS.fd \\\ngo run main.go\n</code></pre> <p>Export the agent grpc url from computation server logs</p> <pre><code>export AGENT_GRPC_URL=localhost:6100\n</code></pre> <p>Upload the algorithm</p> <pre><code>./build/cocos-cli algo ./test/manual/algo/linreg.tar ./private.pem -a docker\n</code></pre> <p>Upload the dataset</p> <pre><code>./build/cocos-cli data ./test/manual/data/iris.csv ./private.pem\n</code></pre> <p>After some time when the results are ready, you can run the following command to get the results:</p> <pre><code>./build/cocos-cli results ./private.pem\n</code></pre> <p>The logs will be similar to this:</p> <pre><code>2024/08/19 14:14:31 Retrieving computation result file\n2024/08/19 14:14:31 Computation result retrieved and saved successfully!\n</code></pre> <p>Unzip the results</p> <pre><code>unzip results.zip -d results\n</code></pre> <p>To make inference on the results, you can use the following command:</p> <pre><code>python3 test/manual/algo/lin_reg.py predict results/model.bin  test/manual/data/\n</code></pre> <p>Terminal recording session</p> <p></p>"},{"location":"algorithms/#wasm-modules","title":"Wasm Modules","text":"<p>WebAssembly (wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust, enabling deployment on the web for client and server applications. Wasm modules can be run on the enclave.</p>"},{"location":"algorithms/#running-wasm-algorithms","title":"Running WASM Algorithms","text":"<p>NOTE: Make sure you have terminated the previous computation before starting a new one.</p>"},{"location":"algorithms/#download-wasm-examples","title":"Download WASM Examples","text":"<p>Download the examples from the AI repository and follow the instructions in the README file to compile one of the examples.</p> <pre><code>git clone https://github.com/ultravioletrs/ai\n</code></pre>"},{"location":"algorithms/#build-addition-wasm-example","title":"Build Addition WASM example","text":"<p>Make sure you have Rust installed. If not, you can install it by following the instructions here.</p> <pre><code>cd ai/burn-algorithms/addition-inference\n</code></pre> <pre><code>cargo build --release --target wasm32-wasip1 --features cocos\n</code></pre> <p>This will generate the wasm module in the <code>../target/wasm32-wasip1/release</code> folder. Copy the module to the <code>cocos</code> folder.</p> <pre><code>cp ../target/wasm32-wasip1/release/addition-inference.wasm ../../../cocos\n</code></pre> <p>Start the computation server:</p> <pre><code>go run ./test/computations/main.go ./addition-inference.wasm public.pem true\n</code></pre> <p>Start the manager</p> <pre><code>sudo \\\nMANAGER_QEMU_SMP_MAXCPUS=4 \\\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_ENABLE_SEV_SNP=false \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/x64/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/x64/OVMF_VARS.fd \\\ngo run main.go\n</code></pre> <p>Export the agent grpc url from computation server logs</p> <pre><code>export AGENT_GRPC_URL=localhost:6013\n</code></pre> <p>Upload the algorithm</p> <pre><code>./build/cocos-cli algo ./addition-inference.wasm ./private.pem -a wasm\n</code></pre> <p>Since the algorithm is a wasm module, we don't need to upload the requirements file. Also, this is the addition example so we don't need to upload the dataset.</p> <p>Finally, download the results</p> <pre><code>./build/cocos-cli result ./private.pem\n</code></pre> <p>Unzip the results</p> <pre><code>unzip result.zip -d results\n</code></pre> <pre><code>cat results/results/results.txt\n</code></pre> <p>The output will be similar to this:</p> <pre><code>\"[5.141593, 4.0, 5.0, 8.141593]\"\n</code></pre> <p>Terminal recording session</p> <p></p> <p>For real-world examples to test with cocos, see our AI repository.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>CocosAI system is running on the host, and it's main goal is to enable:</p> <ul> <li>Programatic creation of enclaves (TEEs)</li> <li>Guest OS and system environment within the enclave VMs</li> <li>Monitoring of enclaves</li> <li>In-enclave SW manager agent</li> <li>Ecrypted data transfer into the enclave and computation execution</li> <li>Result retrieval via encrypted channel to an authorized party</li> <li>Providing of HW measurement and attestation report</li> <li>Enablement of vTPM and DICE integrity checks (root chain of trust) in order to ensure secure boot of the TEEs</li> </ul> <p>These features are implemented by several independent components of CocosAI system:</p> <ol> <li>Manager</li> <li>Agent</li> <li>EOS (Enclave Operating System)</li> <li>CLI</li> </ol> <p></p> <p>N.B. CocosAI open-source project does not provide Computation Management service. It is a cloud component, used to define a Computation (i.e. define computation metadata, like participants list, algorithm and data providers, result recipients, etc...). Ultraviolet provides commercial product Prism, a multi-party computation platform, that implements multi-tenant and scalable Computation Management service, running in the cloud or on premise, and capable to connect and control CocosAI system running on the TEE host.</p>"},{"location":"architecture/#manager","title":"Manager","text":"<p>Manager is a gRPC client that listens to requests sent through gRPC and sends them to Agent via vsock. Manager creates a secure enclave and loads the computation where the agent resides. The connection between Manager and Agent is through vsock, through which channel agent sends events periodically to manager, who forwards these via gRPC.</p> <p>For more information on Manager, please refer to Manager docs.</p>"},{"location":"architecture/#agent","title":"Agent","text":"<p>Agent defines firmware which goes into the TEE and is used to control and monitor computation within TEE and enable secure and encrypted communication with the outside world (in order to fetch the data and provide the result of the computation). The Agent contains a gRPC server that listens for requests from gRPC clients. Communication between the Manager and Agent is done via vsock. The Agent sends events to the Manager via vsock, which then forwards these via gRPC. Agent contains a gRPC server that exposes useful functions that can be accessed by other gRPC clients such as the CLI.</p> <p>For more information on Agent, please refer to Agent docs.</p>"},{"location":"architecture/#eos","title":"EOS","text":"<p>EOS, or Enclave Operating System, is custom lightweight linux distribution built on buildroot linux. It contains agent and other packages required to run workloads in the TEE.</p>"},{"location":"architecture/#cli","title":"CLI","text":"<p>CoCoS CLI is used to access the agent within the secure enclave. CLI communicates to agent using gRPC, with functions such as algo to provide the algorithm to be run, data to provide the data to be used in the computation, and run to start the computation. It also has functions to fetch and validate the attestation report of the enclave.</p> <p>For more information on CLI, please refer to CLI docs.</p>"},{"location":"attestation/","title":"Attestation","text":"<p>Remote attestation is a process in which one side (the attester) collects information about itself and sends that information to the client (or the relying party) so that the relying party can verify the attester. The successful verification proves to the relying party that the secure virtual machine (SVM) runs the expected code on the expected hardware and is configured correctly. If the attester is deemed trustworthy, the relying party will send confidential code/data to the attester. This information implies that a secure channel needs to be formed between the attester and the relaying party. The secure channel is created using attested TLS.</p> <p>Cocos has two software components that represent the attester and the relying party:</p> <ol> <li>The Agent - software application that is running inside the HAL. It is responsible for fetching the attestation report and running the computation.</li> <li>Cocos CLI - a command-line application running on the machines of each Secure Multiparty Computation (SMPC) member. It verifies the attestation report and sends confidential code/data to the Agent.</li> </ol>"},{"location":"attestation/#what-are-the-parts-of-the-attestation-report","title":"What are the parts of the attestation report?","text":"<p>One of the essential parts of the attestation report is the measurement. The measurement represents the hash of the entire SVM or the hash of the HAL. This way, the measurement provides a way for the client to verify the contents of the entire SVM.</p> <p>Along with the measurement, the attestation report provides additional information about the booted SVM and underlying hardware, such as the policy with which the SVM was booted and the SNP firmware's trusted computing base (TCB) version.</p> <p>The AMD SEV-SNP attestation report can also be filled with arbitrary data. The width of this data field is 512 bits, and it is called report data. The report data content is provided by the Agent to the ASP every time the attestation report is generated.</p> <p>The last part of the report is the signature. The hardware signs the AMD SEV-SNP attestation report using the Versioned Chip Endorsement Key (VCEK). VCEK is derived from chip unique secrets and the current SNP firmware TCB. The signature is verified by obtaining the certificate for the VCEK from the AMD Key Distribution System (KDS). By verifying the signature, the relying party can be sure that the SVM is running on genuine AMD hardware and that the AMD Secure Processor (ASP) generated the attestation report.</p>"},{"location":"attestation/#how-is-the-attestation-report-fetched","title":"How is the attestation report fetched?","text":"<p>The Agent is responsible for fetching the attestation report from the SVM. This procedure is safe because the Kernel and the ASP can exchange encrypted messages that can only be decrypted by the Kernel and the ASP. The keys used for the encryption/decryption are inserted by the ASP into the memory of the SVM during boot, thus ensuring that only the ASP and the SVM have the keys for safe communication.</p>"},{"location":"attestation/#attested-tls","title":"Attested TLS","text":"<p>For the relying party to send confidential data or code to the Agent, a secure channel must be established between them. This is done using attested TLS, which is a TLS connection where the server's certificate is extended with the attestation report. The SVM is the server in Cocos. The Agent generates a self-signed x.509 certificate extended with the attestation report. When fetching the attestation report, the Agent inserts the hash of the public key into it using the field report data. The whole process can be seen in the below picture. The green color represents the trusted part of the system, while the red is untrusted.</p> <p></p> <p>The relying party uses the Cocos CLI to verify the self-signed certificate and the attestation report that is part of it. Successful verification proves to the relying party that the certificate is generated inside the SVM because the certificate's public key is part of the attestation report.</p>"},{"location":"cli/","title":"Agent CLI","text":"<p>The CLI allows you to perform various tasks related to the computation and management of algorithms, datasets and TEE. The CLI is a gRPC client for the agent service. To communicate with agent, digital signatures are required for auth against the roles such dataset provider.</p>"},{"location":"cli/#build","title":"Build","text":"<p>To build the CLI, follow these steps:</p> <ol> <li>Clone the repository: <code>go get github.com/ultravioletrs/cocos</code>.</li> <li>Navigate to the project root: <code>cd cocos</code>.</li> <li>Build the CLI binary: <code>make cli</code>.</li> </ol>"},{"location":"cli/#usage","title":"Usage","text":""},{"location":"cli/#generate-keys","title":"Generate Keys","text":"<p>To generate a public &amp; private key pair, run the following command:</p> <pre><code>./build/cocos-cli keys\n</code></pre> <p>This will generate a key pair of type rsa. Different key types can be generated using the <code>-k</code> flag. Currently supported types on cocos are rsa, ecdsa and ed25519.</p> <pre><code>./build/cocos-cli keys -k ecdsa\n</code></pre>"},{"location":"cli/#set-agent-url","title":"Set Agent URL","text":"<p>For commands involving sending data to agent (data and algo upload, result fetching), the agent url is required since cli uses this to connect to the specified agent.</p> <pre><code>export AGENT_GRPC_URL=&lt;agent_host:agent_port&gt;\n</code></pre> <p>Agent port is found from the manager logs after the TEE has been provisioned and agent inserted.</p>"},{"location":"cli/#upload-algorithm","title":"Upload Algorithm","text":"<p>To upload an algorithm, use the following command:</p> <pre><code>./build/cocos-cli algo /path/to/algorithm /path/to/private/key\n</code></pre> <p>Currently, support is provided for four types of algorithms: executable binaries, Python files, Docker images (provided as tar files) and Wasm modules. The above command expects an algorithm in binary format that will be executed inside the secure VM by the agent. For Python files, the algo file, the requirements file, and the Python runtime are required. More information on how to run the other types of algorithms can be found here. To run a python file, use the following command:</p> <pre><code>./build/cocos-cli algo /path/to/algorithm /path/to/private/key --algorithm python --requirements /path/to/requirements.txt --python-runtime python\n</code></pre> <p>The agent grpc url is required for this operation, this will be available once the TEE has been provisioned and agent is running.</p> <p>Supported flags:</p> <pre><code>  -a, --algorithm string        Algorithm type to run (default \"bin\")\n  -h, --help                    help for algo\n      --python-runtime string   Python runtime to use (default \"python3\")\n  -r, --requirements string     Python requirements file\n</code></pre>"},{"location":"cli/#upload-dataset","title":"Upload Dataset","text":"<p>To upload a dataset, use the following command:</p> <pre><code>./build/cocos-cli data /path/to/dataset.csv /path/to/private/key\n</code></pre> <p>The agent grpc url is required for this operation, this will be available once the TEE has been provisioned and agent is running.</p>"},{"location":"cli/#retrieve-result","title":"Retrieve Result","text":"<p>To retrieve the computation result, use the following command:</p> <pre><code>./build/cocos-cli result /path/to/private/key\n</code></pre> <p>If the result is available and agent is ready to receive the results, the result will be extracted and written to the current directory as <code>result.bin</code>.</p> <p>The agent grpc url is required for this operation, this will be available once the TEE has been provisioned and agent is running.</p>"},{"location":"cli/#fetch-and-validate-attestation-report","title":"Fetch and Validate Attestation Report","text":"<p>To fetch or validate the attestation report, use the following commands.</p> <p>To fetch attestation report:</p> <pre><code>./build/cocos-cli attestation get &lt;report_data&gt;\n</code></pre> <p>To validate attestation report</p> <pre><code>./build/cocos-cli attestation validate &lt;attestation_report_file_path&gt; --report_data &lt;report_data&gt;\n</code></pre> <p>To validate the report data, the report data flag is compulsory.</p> <p>Optional Flags:</p> <pre><code>      --CA_bundles stringArray                  PEM format CA bundles for the AMD product. Combined with contents of cabundle_paths.\n      --CA_bundles_paths stringArray            Paths to CA bundles for the AMD product. Must be in PEM format, ASK, then ARK certificates. If unset, uses embedded root certificates.\n      --check_crl                               Download and check the CRL for revoked certificates.\n      --chip_id bytesHex                        The expected MEASUREMENT field as a hex string. Must encode 48 bytes. Unchecked if unset.\n      --config string                           Serialized json check.Config protobuf. This will overwrite individual flags. Unmarshalled as json.\n      --family_id bytesHex                      The expected FAMILY_ID field as a hex string. Must encode 16 bytes. Unchecked if unset.\n      --guest_policy uint                       The most acceptable guest SnpPolicy. (default 196608)\n  -h, --help                                    help for validate\n      --host_data bytesHex                      The expected HOST_DATA field as a hex string. Must encode 32 bytes. Unchecked if unset.\n      --image_id bytesHex                       The expected IMAGE_ID field as a hex string. Must encode 16 bytes. Unchecked if unset.\n      --max_retry_delay duration                Maximum Duration to wait between HTTP request retries. (default 30s)\n      --measurement bytesHex                    The expected MEASUREMENT field as a hex string. Must encode 48 bytes. Unchecked if unset.\n      --minimum_build uint32                    The 8-bit minimum build number for AMD-SP firmware\n      --minimum_guest_svn uint32                The most acceptable GUEST_SVN.\n      --minimum_lauch_tcb uint                  The minimum acceptable value for LAUNCH_TCB.\n      --minimum_tcb uint                        The minimum acceptable value for CURRENT_TCB, COMMITTED_TCB, and REPORTED_TCB.\n      --minimum_version string                  Minimum AMD-SP firmware API version (major.minor). Each number must be 8-bit non-negative. (default \"0.0\")\n      --platform_info string                    The maximum acceptable PLATFORM_INFO field bit-wise. May be empty or a 64-bit unsigned integer\n      --product string                          The AMD product name for the chip that generated the attestation report.\n      --report_data bytesHex                    The expected REPORT_DATA field as a hex string. Must encode 64 bytes. Must be set.\n      --report_id bytesHex                      The expected REPORT_ID field as a hex string. Must encode 32 bytes. Unchecked if unset.\n      --report_id_ma bytesHex                   The expected REPORT_ID_MA field as a hex string. Must encode 32 bytes. Unchecked if unset.\n      --require_author_key                      Require that AUTHOR_KEY_EN is 1.\n      --require_id_block                        Require that the VM was launch with an ID_BLOCK signed by a trusted id key or author key\n      --stepping string                         The machine stepping for the chip that generated the attestation report. Default unchecked.\n      --timeout duration                        Duration to continue to retry failed HTTP requests. (default 2m0s)\n      --trusted_author_key_hashes stringArray   Hex-encoded SHA-384 hash values of trusted author keys in AMD public key format\n      --trusted_author_keys stringArray         Paths to x.509 certificates of trusted author keys\n      --trusted_id_key_hashes stringArray       Hex-encoded SHA-384 hash values of trusted identity keys in AMD public key format\n      --trusted_id_keys stringArray             Paths to x.509 certificates of trusted author keys\n</code></pre>"},{"location":"cli/#file-hash","title":"File Hash","text":"<p>To run a computation, the hash of the files to be uploaded is provided along with the computation manifest. The file hash can be generated by cli, and this can be done using the following command:</p> <pre><code>./build/cocos-cli file-hash /path/to/file\n</code></pre>"},{"location":"cli/#backend-info","title":"Backend Info","text":"<p>To change or add information about the backend, the following commands can be used.</p> <p>To add measurement data:</p> <pre><code>./build/cocos-cli backend measurement &lt;measurement&gt; &lt;backend_info.json&gt;\n</code></pre> <p>To add host data:</p> <pre><code>./build/cocos-cli backend hostdata &lt;host-data&gt; &lt;backend_info.json&gt;\n</code></pre> <p>The backend information is obtained from the backend that has SEV. Check backend info readme for information on how to run the script to generate backend info.</p>"},{"location":"cli/#fetch-amd-sev-snps-ca-bundle-ask-and-ark","title":"Fetch AMD SEV-SNPs CA Bundle (ASK and ARK)","text":"<p>To fetch the CA bundle for SEV-SNP, use the following commands:</p> <pre><code>./build/cocos-cli ca-bundle &lt;path_to_platform_info.json&gt;\n</code></pre>"},{"location":"cli/#installation","title":"Installation","text":"<p>To install the CLI locally, i.e. for the current user:</p> <p>Run <code>cp ./build/cocos-cli $GOBIN</code>.</p>"},{"location":"cli/#notes","title":"Notes","text":"<ul> <li>The CLI supports various configuration flags and options</li> <li>Use the <code>--help</code> flag with any command to see additionalinformation</li> <li>The CLI uses gRPC for communication with the agent service</li> <li>All traffic between CLI and the TEE is encrypted via mutual TLS</li> </ul>"},{"location":"computation/","title":"Computation","text":"<p>Computation in CocosAI is any execution of a program (Algorithm) on a data set (Data), that can be one data file, or a lot of files coming from different parties.</p> <p>Computations are multi-party, meaning that program and data providers can be different parties that do not want to expose their intellectual property to other parties participating in the computation.</p> <p><code>Computation</code> is a structure that holds all the necessary information needed to execute the computation securely (list of participants, execution backend - i.e. where computation will be executed, role of each participant, cryptographic certificates, etc...).</p>"},{"location":"computation/#computation-roles","title":"Computation Roles","text":"<p>Computation is multi-party, i.e. has multiple participants. Each of the users that participate in the computation can have one of the following roles:</p> <ol> <li>Computation Owner - user that created the <code>Computation</code> and that defines who will participate in it and with which role (by inviting other users to the Computation)</li> <li>Algorithm Provider - user that will provide the actual program to be executed</li> <li>Data Provider - user that will provide data on which the algorithm will be executed, i.e. data which algorithm will process. Datasets are optional.</li> <li>Result Consumer - user that will recieve result after the processing</li> </ol> <p>One user can have several roles - for example, an Algorithm Provider can also be a Result Recipient.</p>"},{"location":"computation/#computation-manifest","title":"Computation Manifest","text":"<p>Computation Manifest represents the Computation description and is sent upon <code>run</code> command to the Manager.</p> <p>Manager fetches the Computation Manifest and sends it into the TEE to Agent, via vsock.</p> <p>The first thing that Agent does upon boot, is that it fetches the Computation Manifest and reads it. For this Manifest, Agent understands who are the participants in the computation adn with wich role, i.e. from whom it can accept the connections and what data they will send. Agent also learns from the Manifest what algorithm is used and how many datasets will be provided. This way it knows when it received all necessary files to start the execution. Finally, Agent learns from the Manifest to whom it needs to send the Result of the computation.</p>"},{"location":"developer-guide/","title":"Developer Guide","text":""},{"location":"developer-guide/#getting-cocos","title":"Getting CoCos","text":"<p>CoCos is found on the CoCos repository. You should fork the repository in order to make changes to the repository. After forking the repository, you can clone it as follows:</p> <pre><code>git clone &lt;forked repository&gt; $SOMEPATH/cocos\ncd $SOMEPATH/cocos\n</code></pre>"},{"location":"developer-guide/#building","title":"Building","text":""},{"location":"developer-guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>Protocol Buffers</li> <li>Golang</li> </ul>"},{"location":"developer-guide/#build-all-services","title":"Build All Services","text":"<p>Use the GNU Make tool to build all CoCos services <code>make</code>. Build artifacts will be put in the build directory.</p>"},{"location":"developer-guide/#building-hal","title":"Building HAL","text":"<p>To build the custom linux image that will host agent, run:</p> <pre><code>git clone https://github.com/buildroot/buildroot.git\ncd buildroot\ngit checkout 2024.11-rc2 \nmake BR2_EXTERNAL=../cocos/hal/linux cocos_defconfig\nmake menuconfig #optional for additional configuration\nmake\n</code></pre>"},{"location":"developer-guide/#testing-hal-image","title":"Testing HAL image","text":""},{"location":"developer-guide/#enable-v-sock","title":"Enable V-Sock","text":"<p>The necessary kernel modules must be loaded on the hypervisor.</p> <pre><code>sudo modprobe vhost_vsock\nls -l /dev/vhost-vsock\n# crw-rw-rw- 1 root kvm 10, 241 Jan 16 12:05 /dev/vhost-vsock\nls -l /dev/vsock\n# crw-rw-rw- 1 root root 10, 121 Jan 16 12:05 /dev/vsock\n</code></pre>"},{"location":"developer-guide/#launch-the-vm","title":"Launch the VM","text":"<p>To launch the virtual machine containing agent for testing purposes, run:</p> <pre><code>sudo find / -name OVMF_CODE.fd\n# =&gt; /usr/share/OVMF/OVMF_CODE.fd\nOVMF_CODE=/usr/share/OVMF/OVMF_CODE.fd\n\nsudo find / -name OVMF_VARS.fd\n# =&gt; /usr/share/OVMF/OVMF_VARS.fd\nOVMF_VARS=/usr/share/OVMF/OVMF_VARS.fd\n\nKERNEL=\"buildroot/output/images/bzImage\"\nINITRD=\"buildroot/output/images/rootfs.cpio.gz\"\n\nqemu-system-x86_64 \\\n-enable-kvm \\\n-cpu EPYC-v4 \\\n-machine q35 \\\n-smp 4 \\\n-m 2048M,slots=5,maxmem=10240M \\\n-no-reboot \\\n-drive if=pflash,format=raw,unit=0,file=$OVMF_CODE,readonly=on \\\n-netdev user,id=vmnic,hostfwd=tcp::7020-:7002 \\\n-device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= \\\n-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 \\\n-kernel $KERNEL \\\n-append \"earlyprintk=serial console=ttyS0\" \\\n-initrd $INITRD \\\n-nographic \\\n-monitor pty \\\n-monitor unix:monitor,server,nowait\n</code></pre> <p>The default password is <code>root</code>.</p>"},{"location":"developer-guide/#testing-agent-independently","title":"Testing Agent Independently","text":"<p>Agent once started will wait to receive its configuration via v-sock. For testing purposes you can use the script in <code>cocos/test/manual/agent-config</code>. This script sends agent config and also receives logs and events from agent. Once the VM is launched you can send config including computation manifest to agent as follows:</p> <pre><code>cd cocos\ngo run ./test/manual/agent-config/main.go &lt;data-path&gt; &lt;algo-path&gt; &lt;public-key-path&gt; &lt;attested-tls-bool&gt;\n</code></pre>"},{"location":"developer-guide/#testing-manager","title":"Testing Manager","text":"<p>Manager is a gRPC client and needs gRPC sever to connect to. We have an example server for testing purposes in <code>test/computations</code>. Run the server as follows:</p> <pre><code>go run ./test/computations/main.go /path/to/algo/file /path/to/public/key/file &lt;attested_tls_bool&gt; /path/to/data/file1.zip path/to/data/file2.zip path/to/data/file3.zip\n</code></pre>"},{"location":"developer-guide/#run-manager","title":"Run Manager","text":"<p>Create two directories in <code>cocos/cmd/manager</code>, the directories are <code>img</code> and <code>tmp</code>. Copy <code>rootfs.cpio.gz</code> and <code>bzImage</code> from the buildroot output directory files to <code>cocos/cmd/manager/img</code>.</p> <p>Next run manager client.</p> <pre><code>cd cmd/manager\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_USE_SUDO=false \\\nMANAGER_QEMU_ENABLE_SEV=false \\\nMANAGER_QEMU_SEV_CBITPOS=51 \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/ovmf/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/ovmf/OVMF_VARS.fd \\\n./build/cocos-manager\n</code></pre> <p>This will result in manager sending a whoIam request to manager-server. Manager server will then launch a VM with agent running and having received the computation manifest.</p>"},{"location":"developer-guide/#protobuf","title":"Protobuf","text":"<p>If you've made any changes to .proto files, you should call protoc command prior to compiling individual microservices.</p> <p>To do this by hand, execute: <code>make protoc</code></p>"},{"location":"developer-guide/#mocks","title":"Mocks","text":"<p>To run tests, some of the services are mocked and these need to be updated if the function signatures are changed.</p> <p>To do this, execute: <code>make mocks</code></p>"},{"location":"developer-guide/#troubleshooting","title":"Troubleshooting","text":"<p>If you run <code>ps aux | grep qemu-system-x86_64</code> and it returns give you something like this:</p> <pre><code>sammy      13913  0.0  0.0      0     0 pts/2    Z+   20:17   0:00 [qemu-system-x86] &lt;defunct&gt;\n</code></pre> <p>means that the a QEMU virtual machine that is currently defunct, meaning that it is no longer running. More precisely, the defunct process in the output is also known as a \"zombie\" process.</p>"},{"location":"developer-guide/#kill-qemu-system-x86_64-processes","title":"Kill <code>qemu-system-x86_64</code> Processes","text":"<p>To kill any leftover <code>qemu-system-x86_64</code> processes, use <code>pkill -f qemu-system-x86_64</code> The pkill command is used to kill processes by name or by pattern. The <code>-f</code> flag to specify that we want to kill processes that match the pattern <code>qemu-system-x86_64</code>. It sends the SIGKILL signal to all processes that are running <code>qemu-system-x86_64</code>.</p> <p>If this does not work, i.e. if <code>ps aux | grep qemu-system-x86_64</code> still outputs <code>qemu-system-x86_64</code> related process(es), you can kill the unwanted process with <code>kill -9 &lt;PID&gt;</code>, which also sends a SIGKILL signal to the process.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding install the following requirements.</p> <ul> <li>Golang (version 1.21.6)</li> </ul>"},{"location":"getting-started/#getting-cocos","title":"Getting COCOS","text":"<p>Get the cocos repository:</p> <pre><code>git clone https://github.com/ultravioletrs/cocos.git\n</code></pre>"},{"location":"getting-started/#hal","title":"HAL","text":"<p>Get the hardware abstraction layer from the releases on the cocos repository. Two files will be required:</p> <ul> <li><code>rootfs.cpio.gz</code> - Initramfs</li> <li><code>bzImage</code> - Kernel</li> </ul> <p>Create two directories in <code>cocos/cmd/manager</code>, which are <code>img</code> and <code>tmp</code>.</p> <pre><code>mkdir -p cocos/cmd/manager/img cocos/cmd/manager/tmp\n</code></pre> <p>Copy the downloaded files to <code>cocos/cmd/manager/img</code>.</p> <pre><code>wget https://github.com/ultravioletrs/cocos/releases/download/v0.2.0/bzImage -P cocos/cmd/manager/img\nwget https://github.com/ultravioletrs/cocos/releases/download/v0.2.0/rootfs.cpio.gz -P cocos/cmd/manager/img\n</code></pre> <p>If using the latest version of cocos see the Developer guide for instructions on building HAL.</p>"},{"location":"getting-started/#generating-keys","title":"Generating Keys","text":"<p>Generate a public and private key pair for user communication with agent on cli.</p> <p>Build cli</p> <pre><code>cd cocos\n</code></pre> <pre><code>make cli\n</code></pre> <p>Generate keys</p> <pre><code>./build/cocos-cli keys\n</code></pre> <p>The output will be similar to this:</p> <pre><code>2024/08/11 23:44:40 Successfully generated public/private key pair of type: *rsa.PrivateKey\n</code></pre> <p>The keys will be saved as <code>public.pem</code> and <code>private.pem</code> in the current directory.</p>"},{"location":"getting-started/#starting-computations-server","title":"Starting Computations Server","text":"<p>The manager is a gRPC client and needs a gRPC server to connect to. We have an example server for testing purposes in <code>test/computations</code>. Run the server as follows:</p> <pre><code>go run ./test/computations/main.go &lt;algo-path&gt; &lt;public-key-path&gt; &lt;attested-tls-bool&gt; &lt;data-paths&gt;\n</code></pre> <p><code>data-paths</code> can be empty, a single file or multiple files depending on the nature of the algorithm and type of data.</p> <p>For example</p> <pre><code>go run ./test/computations/main.go ./test/manual/algo/addition.py ./public.pem false\n</code></pre> <p>Since this is an addition example, the data paths are empty.</p> <p>The output will be similar to this:</p> <pre><code>{\"time\":\"2024-08-12T00:05:13.321374245+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n</code></pre> <p>The test server uses the paths to the algorithm and datasets to obtain the file and include the file hashes in the computation manifest. The files are uploaded to the agent via cli. The public key provided can be generated using OpenSSL or cocos-cli.</p>"},{"location":"getting-started/#running-manager","title":"Running Manager","text":"<p>Next, we need to start manager. But first, we'll need to install some prerequisites.</p>"},{"location":"getting-started/#vsock","title":"Vsock","text":"<p>Virtio-vsock is a host/guest communications device. It allows applications in the guest and host to communicate. In this case, it is used to communicate between the manager and the agent. To enable it run the following on the host:</p> <pre><code>sudo modprobe vhost_vsock\n</code></pre> <p>to confirm that it is enabled run:</p> <pre><code>ls -l /dev/vsock\n</code></pre> <p>The output will be similar to this:</p> <pre><code>crw-rw-rw- 1 root root 10, 122 Aug 11 23:47 /dev/vsock\n</code></pre> <p>and</p> <pre><code>ls -l /dev/vhost-vsock\n</code></pre> <p>The output will be similar to this:</p> <pre><code>crw-rw-rw- 1 root kvm 10, 241 Aug 11 23:47 /dev/vhost-vsock\n</code></pre>"},{"location":"getting-started/#ovmf","title":"OVMF","text":"<p>Find the ovmf code file:</p> <pre><code>sudo find / -name OVMF_CODE.fd\n</code></pre> <p>The output will be similar to this:</p> <pre><code>/usr/share/edk2/ia32/OVMF_CODE.fd\n/usr/share/edk2/x64/OVMF_CODE.fd\n/usr/share/OVMF/OVMF_CODE.fd\n</code></pre> <p>Find the ovmf vars file:</p> <pre><code>sudo find / -name OVMF_VARS.fd\n</code></pre> <p>the output will be similar to this</p> <pre><code>/usr/share/edk2/ia32/OVMF_VARS.fd\n/usr/share/edk2/x64/OVMF_VARS.fd\n/usr/share/OVMF/OVMF_VARS.fd\n</code></pre>"},{"location":"getting-started/#run","title":"Run","text":"<p>When the manager connects to the computations server, the server then sends a computation manifest. In response, the manager will send logs and events from the computation both from the manager and the agent. To start run:</p> <pre><code>cd cmd/manager\n</code></pre> <pre><code>sudo \\\nMANAGER_QEMU_SMP_MAXCPUS=4 \\\nMANAGER_GRPC_URL=localhost:7001 \\\nMANAGER_LOG_LEVEL=debug \\\nMANAGER_QEMU_ENABLE_SEV_SNP=false \\\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/edk2/x64/OVMF_CODE.fd \\\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/edk2/x64/OVMF_VARS.fd \\\ngo run main.go\n</code></pre> <p>The output of the manager will be similar to this:</p> <pre><code>{\"time\":\"2024-08-12T00:05:21.119156392+03:00\",\"level\":\"INFO\",\"msg\":\"-enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=4 -m 2048M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/edk2/x64/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=/usr/share/edk2/x64/OVMF_VARS.fd -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,addr=0x2,romfile= -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 -vnc :0 -kernel img/bzImage -append \\\"earlyprintk=serial console=ttyS0\\\" -initrd img/rootfs.cpio.gz -nographic -monitor pty\"}\n{\"time\":\"2024-08-12T00:05:38.725566058+03:00\",\"level\":\"INFO\",\"msg\":\"Method Run for computation took 17.591835113s to complete\"}\n{\"time\":\"2024-08-12T00:05:38.727745349+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"receivingAlgorithm\\\" timestamp:{seconds:1723410338 nanos:718187674} computation_id:\\\"1\\\" originator:\\\"agent\\\" status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-08-12T00:05:38.727737113+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: receivingManifest -&gt; receivingManifest\\\\n\\\" computation_id:\\\"1\\\" level:\\\"DEBUG\\\" timestamp:{seconds:1723410338 nanos:717822747}}\"}\n{\"time\":\"2024-08-12T00:05:38.727829542+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"agent service gRPC server listening at :7002 without TLS\\\" computation_id:\\\"1\\\" level:\\\"INFO\\\" timestamp:{seconds:1723410338 nanos:718373804}}\"}\n2024/08/12 00:05:41 traces export: Post \"http://localhost:4318/v1/traces\": dial tcp [::1]:4318: connect: connection refused\n</code></pre> <p>The output on the manager test server will be similar to this:</p> <pre><code>{\"time\":\"2024-08-12T00:05:13.321374245+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n{\"time\":\"2024-08-12T00:05:21.132925448+03:00\",\"level\":\"DEBUG\",\"msg\":\"received who am on ip address [::1]:39498\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1723410321 nanos:133669966} computation_id:\"1\" originator:\"manager\" status:\"starting\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1723410321 nanos:133914629} computation_id:\"1\" originator:\"manager\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"char device redirected to /dev/pts/7 (label compat_monitor0)\\n\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1723410321 nanos:149109340}}\nreceived agent log\n&amp;{message:\"\\x1b[2J\\x1b[01\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1723410321 nanos:566143873}}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1723410338 nanos:725491805} computation_id:\"1\" originator:\"manager\" status:\"complete\"}\nreceived runRes\n&amp;{agent_port:\"6006\" computation_id:\"1\"}\nreceived agent log\n&amp;{message:\"Transition: receivingManifest -&gt; receivingManifest\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1723410338 nanos:717822747}}\nreceived agent event\n&amp;{event_type:\"receivingAlgorithm\" timestamp:{seconds:1723410338 nanos:718187674} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"agent service gRPC server listening at :7002 without TLS\" computation_id:\"1\" level:\"INFO\" timestamp:{seconds:1723410338 nanos:718373804}}\n</code></pre>"},{"location":"getting-started/#uploading-artefacts","title":"Uploading artefacts","text":"<p>From the logs we see agent has been bound to port <code>6006</code> which we can use with agent cli to send the algorithm, datasets and retrieve results. In this case, the <code>AGENT_GRPC_URL</code> will be <code>localhost:6006</code>.</p> <p>We export the agent grpc url</p> <pre><code>export AGENT_GRPC_URL=localhost:6006\n</code></pre> <p>Upload the algorithm</p> <pre><code>./build/cocos-cli algo ./test/manual/algo/addition.py ./private.pem -a python\n</code></pre> <p>The output will be similar to this:</p> <pre><code>2024/08/12 00:06:34 Uploading algorithm binary: ./test/manual/algo/addition.py\nUploading algorithm...  100% [=========================================================================================================================&gt;]\n2024/08/12 00:06:34 Successfully uploaded algorithm\n</code></pre>"},{"location":"getting-started/#reading-the-results","title":"Reading the results","text":"<p>Since this algorithm doesn't have a dataset we can go straight to reading the results</p> <pre><code>./build/cocos-cli result ./private.pem\n</code></pre> <p>The output will be similar to this:</p> <pre><code>2024/08/12 00:06:54 Retrieving computation result file\n2024/08/12 00:06:54 Computation result retrieved and saved successfully!\n</code></pre> <p>To read the results</p> <pre><code>unzip result.zip -d results\n</code></pre> <pre><code>cat results/result.txt\n</code></pre> <pre><code>python3 test/manual/algo/addition.py test results/result.txt\n</code></pre> <p>Both should return the same result.</p> <pre><code>15\n</code></pre> <p>The output from the manager will be similar to this:</p> <pre><code>{\"time\":\"2024-08-12T00:05:21.119156392+03:00\",\"level\":\"INFO\",\"msg\":\"-enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=4 -m 2048M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/edk2/x64/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=/usr/share/edk2/x64/OVMF_VARS.fd -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,addr=0x2,romfile= -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3 -vnc :0 -kernel img/bzImage -append \\\"earlyprintk=serial console=ttyS0\\\" -initrd img/rootfs.cpio.gz -nographic -monitor pty\"}\n{\"time\":\"2024-08-12T00:05:38.725566058+03:00\",\"level\":\"INFO\",\"msg\":\"Method Run for computation took 17.591835113s to complete\"}\n{\"time\":\"2024-08-12T00:05:38.727745349+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"receivingAlgorithm\\\" timestamp:{seconds:1723410338 nanos:718187674} computation_id:\\\"1\\\" originator:\\\"agent\\\" status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-08-12T00:05:38.727737113+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: receivingManifest -&gt; receivingManifest\\\\n\\\" computation_id:\\\"1\\\" level:\\\"DEBUG\\\" timestamp:{seconds:1723410338 nanos:717822747}}\"}\n{\"time\":\"2024-08-12T00:05:38.727829542+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"agent service gRPC server listening at :7002 without TLS\\\" computation_id:\\\"1\\\" level:\\\"INFO\\\" timestamp:{seconds:1723410338 nanos:718373804}}\"}\n2024/08/12 00:05:41 traces export: Post \"http://localhost:4318/v1/traces\": dial tcp [::1]:4318: connect: connection refused\n{\"time\":\"2024-08-12T00:06:34.864291735+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"running\\\" timestamp:{seconds:1723410394 nanos:848027138} computation_id:\\\"1\\\" originator:\\\"agent\\\" status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-08-12T00:06:34.864338115+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"computation run started\\\" computation_id:\\\"1\\\" level:\\\"DEBUG\\\" timestamp:{seconds:1723410394 nanos:847998168}}\"}\n{\"time\":\"2024-08-12T00:06:37.39054944+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: resultsReady -&gt; resultsReady\\\\n\\\" computation_id:\\\"1\\\" level:\\\"DEBUG\\\" timestamp:{seconds:1723410397 nanos:374554947}}\"}\n{\"time\":\"2024-08-12T00:06:37.390624125+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"resultsReady\\\" timestamp:{seconds:1723410397 nanos:374563534} computation_id:\\\"1\\\" originator:\\\"agent\\\" status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-08-12T00:06:54.575981836+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_event:{event_type:\\\"complete\\\" timestamp:{seconds:1723410414 nanos:561105934} computation_id:\\\"1\\\" originator:\\\"agent\\\" status:\\\"in-progress\\\"}\"}\n{\"time\":\"2024-08-12T00:06:54.576028697+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Transition: complete -&gt; complete\\\\n\\\" computation_id:\\\"1\\\" level:\\\"DEBUG\\\" timestamp:{seconds:1723410414 nanos:561077428}}\"}\n{\"time\":\"2024-08-12T00:06:54.583319814+03:00\",\"level\":\"INFO\",\"msg\":\"Agent Log/Event, Computation ID: 1, Message: agent_log:{message:\\\"Method Result took 1.403\u00b5s to complete without errors\\\" computation_id:\\\"1\\\" level:\\\"INFO\\\" timestamp:{seconds:1723410414 nanos:561057047}}\"}\n</code></pre> <p>The output from the agent will be similar to this:</p> <pre><code>{\"time\":\"2024-08-12T00:05:13.321374245+03:00\",\"level\":\"INFO\",\"msg\":\"manager_test_server service gRPC server listening at :7001 without TLS\"}\n{\"time\":\"2024-08-12T00:05:21.132925448+03:00\",\"level\":\"DEBUG\",\"msg\":\"received who am on ip address [::1]:39498\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1723410321 nanos:133669966} computation_id:\"1\" originator:\"manager\" status:\"starting\"}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1723410321 nanos:133914629} computation_id:\"1\" originator:\"manager\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"char device redirected to /dev/pts/7 (label compat_monitor0)\\n\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1723410321 nanos:149109340}}\nreceived agent log\n&amp;{message:\"\\x1b[2J\\x1b[01\" computation_id:\"1\" level:\"debug\" timestamp:{seconds:1723410321 nanos:566143873}}\nreceived agent event\n&amp;{event_type:\"vm-provision\" timestamp:{seconds:1723410338 nanos:725491805} computation_id:\"1\" originator:\"manager\" status:\"complete\"}\nreceived runRes\n&amp;{agent_port:\"6006\" computation_id:\"1\"}\nreceived agent log\n&amp;{message:\"Transition: receivingManifest -&gt; receivingManifest\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1723410338 nanos:717822747}}\nreceived agent event\n&amp;{event_type:\"receivingAlgorithm\" timestamp:{seconds:1723410338 nanos:718187674} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"agent service gRPC server listening at :7002 without TLS\" computation_id:\"1\" level:\"INFO\" timestamp:{seconds:1723410338 nanos:718373804}}\nreceived agent event\n&amp;{event_type:\"running\" timestamp:{seconds:1723410394 nanos:848027138} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"computation run started\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1723410394 nanos:847998168}}\nreceived agent log\n&amp;{message:\"Transition: resultsReady -&gt; resultsReady\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1723410397 nanos:374554947}}\nreceived agent event\n&amp;{event_type:\"resultsReady\" timestamp:{seconds:1723410397 nanos:374563534} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent event\n&amp;{event_type:\"complete\" timestamp:{seconds:1723410414 nanos:561105934} computation_id:\"1\" originator:\"agent\" status:\"in-progress\"}\nreceived agent log\n&amp;{message:\"Transition: complete -&gt; complete\\n\" computation_id:\"1\" level:\"DEBUG\" timestamp:{seconds:1723410414 nanos:561077428}}\nreceived agent log\n&amp;{message:\"Method Result took 1.403\u00b5s to complete without errors\" computation_id:\"1\" level:\"INFO\" timestamp:{seconds:1723410414 nanos:561057047}}\n</code></pre> <p>These logs provide detailed information about the operations of the manager and agent and can be useful for troubleshooting any issues that may arise.</p> <p>For more information on running different algorithms and datasets see the algorithms documentation.</p>"},{"location":"hal/","title":"Hardware Abstraction Layer (HAL)","text":"<p>HAL is a layer of programming that allows the software to interact with the hardware device at a general level rather than at the detailed hardware level. Cocos uses HAL and AMD SEV-SNP as an abstraction layer for confidential computing.</p> <p>AMD SEV-SNP creates secure virtual machines (SVMs). VMs are usually used to run an operating system (e.g., Ubuntu and its applications). To avoid using a whole OS, HAL uses:</p> <ul> <li>Linux kernel v6.12 - vmlinuz archive with the standard Linux kernel v6.12 with support for AMD SEV.</li> <li>File system - the initial RAM file system (initramfs) that is used as the root file system of the VM.</li> </ul> <p>This way, applications can be executed in the SVM, and the whole HAL SVM is entirely in RAM, protected by SEV-SNP. Being a RAM-only SVM means that secrets that are kept in the SVM will be destroyed when the SVM stops working.</p>"},{"location":"hal/#how-is-hal-constructed","title":"How is HAL constructed?","text":"<p>HAL is made using the tool Buildroot. Buildroot is used to create efficient, embedded Linux systems, and we use it to create the compressed image of the kernel (vmlinuz) and the initial file system (initramfs).</p> <p>HAL configuration for Buildroot also includes Python runtime and agent software support. You can read more about the Agent software here.</p>"},{"location":"hal/#how-does-it-work","title":"How does it work?","text":"<p>HAL is combined with AMD SEV-SNP to provide a fully encrypted VM that can be verified using remote attestation. You can read more about the attestation process here.</p> <p>Cocos uses QEMU and Open Virtual Machine Firmware (OVMF) to boot the confidential VM. During boot with SEV-SNP, the AMD Secure Processor (AMD SP) measures (calculates the hash) of the contents of the VM to insert that hash into the attestation report. This measurement is proof of what is currently running inside the VM. The problem with SEV is that it only measures the Open Virtual Machine Firmware (OVMF). To solve this, we have built OVMF so that OVMF contains hashes of the vmlinuz and initrams. Once the OVMF is loaded, it will load the vmlinuz and initramfs into memory, but it will continue the boot process only if the hashes of the vmlinuz and initramfs match the hashes stored in OVMF. This way, the attestation report will contain the measurement of OVMF, with the hashes, and OVMF will guarantee that the correct kernel and file system are booted. The whole process can be seen in the following diagram. The green color represents the trusted part of the system, while the red is untrusted:</p> <p></p> <p>This process guarantees that the whole VM is secure and can be verified.</p> <p>After the kernel boots, the agent is started and ready for work.</p>"},{"location":"manager/","title":"Manager","text":"<p>Manager runs on the TEE-capable host (AMD SEV-SNP, Intel SGX or Intel TDX) and has 2 main roles:</p> <ol> <li>To deploy the well-prepared TEE upon the <code>run</code> command and upload the necessary configuration into it (command line arguments, TLS certificates, etc...)</li> <li>To monitor deployed TEE and provide remot logs</li> </ol> <p>Manager exposes an API for control, based on gRPC, and is controlled by Computation Management service. Manager acts as the client of Computation Management service and connects to it upon the start via TLS-encoded gRPC connection.</p> <p>Computation Management service is used to to configure computation metadata. Once a computation is created by a user and the invited users have uploaded their public certificates (used later for identification and data exchange in the enclave), a run request is sent. The Manager is responsible for creating the TEE in which computation will be ran and managing the computation lifecycle.</p> <p>Communication between Computation Management cloud and the Manager is done via gRPC, while communication between Manager and Agent is done via Virtio Vsock. Vsock is used to send Agent events from the computation in the Agent to the Manager. The Manager then sends the events back to Computation Mangement cloud via gRPC, and these are visible to the end user.</p> <p>The picture below shows where the Manager runs in the Cocos system, helping us better understand its role.</p> <p></p>"},{"location":"manager/#manager-agent","title":"Manager &lt;&gt; Agent","text":"<p>When TEE is booted, an Agent is automatically deployed and is used for outside communication with the enclave (via the API) and for computation orchestration (data and algorithm upload, start of the computation and retrieval of the result).</p> <p>Agent is a gRPC server, and CLI is a gRPC client of the Agent. The Manager sends the Computation Manifest to the Agent via vsock and the Agent runs the computation, according to the Computation Manifest, while sending events back to manager on the status. The Manager then sends the events it receives from agent via vsock to Computation Mangement cloud through gRPC.</p>"},{"location":"manager/#setup-and-test-manager-agent","title":"Setup and Test Manager &lt;&gt; Agent","text":"<pre><code>git clone https://github.com/ultravioletrs/cocos\ncd cocos\n</code></pre> <p>N.B. All relative paths in this document are relative to <code>cocos</code> repository directory.</p>"},{"location":"manager/#qemu-kvm","title":"QEMU-KVM","text":"<p>QEMU-KVM is a virtualization platform that allows you to run multiple operating systems on the same physical machine. It is a combination of two technologies: QEMU and KVM.</p> <ul> <li>QEMU is an emulator that can run a variety of operating systems, including Linux, Windows, and macOS.</li> <li>KVM is a Linux kernel module that allows QEMU to run virtual machines.</li> </ul> <p>To install QEMU-KVM on a Debian based machine, run</p> <pre><code>sudo apt update\nsudo apt install qemu-kvm\n</code></pre> <p>Create <code>img</code> directory in <code>cmd/manager</code>. Create <code>tmp</code> directory in <code>cmd/manager</code>.</p>"},{"location":"manager/#add-v-sock","title":"Add V-sock","text":"<p>The necessary kernel modules must be loaded on the hypervisor.</p> <pre><code>sudo modprobe vhost_vsock\nls -l /dev/vhost-vsock\n# crw-rw-rw- 1 root kvm 10, 241 Jan 16 12:05 /dev/vhost-vsock\nls -l /dev/vsock\n# crw-rw-rw- 1 root root 10, 121 Jan 16 12:05 /dev/vsock\n</code></pre>"},{"location":"manager/#prepare-cocos-hal","title":"Prepare Cocos HAL","text":"<p>Get the hardware abstraction layer from the releases on the cocos repository. Two files will be required:</p> <ul> <li><code>rootfs.cpio.gz</code> - Initramfs</li> <li><code>bzImage</code> - Kernel</li> </ul> <p>Create two directories in <code>cocos/cmd/manager</code>, the directories are <code>img</code> and <code>tmp</code>. Copy the downloaded files to <code>cocos/cmd/manager/img</code>. If using the latest version of cocos see the Developer guide for instructions on building HAL.</p>"},{"location":"manager/#ovmf","title":"OVMF","text":"<p>We need Open Virtual Machine Firmware. OVMF is a port of Intel's tianocore firmware - an open source implementation of the Unified Extensible Firmware Interface (UEFI) - used by a qemu virtual machine. We need OVMF in order to run virtual machine with focal-server-cloudimg-amd64. When we install QEMU, we get two files that we need to start a VM: <code>OVMF_VARS.fd</code> and <code>OVMF_CODE.fd</code>. We will make a local copy of <code>OVMF_VARS.fd</code> since a VM will modify this file. On the other hand, <code>OVMF_CODE.fd</code> is only used as a reference, so we only record its path in an environment variable.</p> <pre><code>sudo find / -name OVMF_CODE.fd\n# =&gt; /usr/share/OVMF/OVMF_CODE.fd\nMANAGER_QEMU_OVMF_CODE_FILE=/usr/share/OVMF/OVMF_CODE.fd\n\nsudo find / -name OVMF_VARS.fd\n# =&gt; /usr/share/OVMF/OVMF_VARS.fd\nMANAGER_QEMU_OVMF_VARS_FILE=/usr/share/OVMF/OVMF_VARS.fd\n</code></pre> <p>NB: we set environment variables that we will use in the shell process where we run <code>manager</code>.</p>"},{"location":"manager/#deployment","title":"Deployment","text":"<p>To start the service, execute the following shell script (note a server needs to be running see here). Additionally, the required environment variables should be set in cocos-manager.env beforehand.</p> <pre><code># download the latest version of the service\ngo get github.com/ultravioletrs/cocos\n\ncd $GOPATH/src/github.com/ultravioletrs/cocos\n</code></pre> <p>Variables should be set at this point in cocos-manager.env.</p> <pre><code># builds binaries, copies them to bin and installs the env variables required for manager\nmake install\n\n# run the service\nmake run\n</code></pre> <p>To enable AMD SEV support, start manager after setting these environment variables in cocos-manager.env.</p> <pre><code>MANAGER_QEMU_USE_SUDO=true\nMANAGER_QEMU_ENABLE_SEV=true\nMANAGER_QEMU_SEV_CBITPOS=51\n</code></pre> <p>You can also enable SEV_SNP through the environment variable:</p> <pre><code>MANAGER_QEMU_ENABLE_SEV_SNP=false\n</code></pre> <p>Then install the service:</p> <pre><code># install the service with the environment variables\nsudo make install\n\n# start the service\nsudo make run\n</code></pre>"},{"location":"manager/#verifying-vm-launch","title":"Verifying VM Launch","text":"<p>NB: To verify that the manager successfully launched the VM, you need to open three terminals on the same machine. In one terminal, you need to launch the computations server by executing (with the environment variables of choice):</p> <pre><code>go run ./test/computations/main.go &lt;algo-path&gt; &lt;public-key-path&gt; &lt;attested-tls-bool&gt; &lt;data-paths&gt;\n</code></pre> <p>and in the second the manager by executing (with the environment variables of choice):</p> <pre><code>sudo make run\n</code></pre> <p>Ensure that the Manager can connect to the computations server by setting the MANAGER_GRPC_URL with the url value of the computations server. In the last terminal window, you can run the verification commands.</p> <p>To verify that the manager launched the VM successfully, run the following command:</p> <pre><code>ps aux | grep qemu-system-x86_64\n</code></pre> <p>You should get something similar to this</p> <pre><code>darko     324763 95.3  6.0 6398136 981044 ?      Sl   16:17   0:15 /usr/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -nographic -monitor pty\n</code></pre> <p>If you run a command as <code>sudo</code>, you should get the output similar to this one</p> <pre><code>root       37982  0.0  0.0   9444  4572 pts/0    S+   16:18   0:00 sudo /usr/local/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -object sev-guest,id=sev0,cbitpos=51,reduced-phys-bits=1 -machine memory-encryption=sev0 -nographic -monitor pty\nroot       37989  122 13.1 5345816 4252312 pts/0 Sl+  16:19   0:04 /usr/local/bin/qemu-system-x86_64 -enable-kvm -machine q35 -cpu EPYC -smp 4,maxcpus=64 -m 4096M,slots=5,maxmem=30G -drive if=pflash,format=raw,unit=0,file=/usr/share/OVMF/OVMF_CODE.fd,readonly=on -drive if=pflash,format=raw,unit=1,file=img/OVMF_VARS.fd -device virtio-scsi-pci,id=scsi,disable-legacy=on,iommu_platform=true -drive file=img/focal-server-cloudimg-amd64.img,if=none,id=disk0,format=qcow2 -device scsi-hd,drive=disk0 -netdev user,id=vmnic,hostfwd=tcp::7020-:7002 -device virtio-net-pci,disable-legacy=on,iommu_platform=true,netdev=vmnic,romfile= -object sev-guest,id=sev0,cbitpos=51,reduced-phys-bits=1 -machine memory-encryption=sev0 -nographic -monitor pty\n</code></pre> <p>The two processes are due to the fact that we run the command <code>/usr/bin/qemu-system-x86_64</code> as <code>sudo</code>, so there is one process for <code>sudo</code> command and the other for <code>/usr/bin/qemu-system-x86_64</code>.</p> <p>You can view logs from manager using the following commands:</p> <pre><code># check manager status\nsudo systemctl status cocos-manager\n\n# follow logs from manager\njournalctl -u cocos-manager -n 20 -f\n</code></pre>"},{"location":"tee/","title":"TEE","text":"<p>A trusted execution environment (TEE) is a separate part of the main memory and the CPU that encrypts code/data and enables \"on the fly\" executions of the said encrypted code/data. One of the examples of TEEs is Intel Secure Guard Extensions (SGX) and AMD Secure Encrypted Virtualization (SEV).</p>"},{"location":"tee/#amd-sev","title":"AMD SEV","text":"<p>AMD SEV and its latest and most secure iteration, AMD Secure Encrypted Virtualization - Secure Nested Paging (SEV-SNP), is the AMD technology that isolates entire virtual machines (VMs). SEV-SNP encrypts the whole VM and provides confidentiality and integrity protection of the VM memory. This way, the hypervisor or any other application on the host machine cannot read the VM memory.</p> <p>In CocosAI, we use an in-memory VM image called the Hardware Abstraction Layer (HAL). You can read more on HAL here.</p> <p>One of the critical components of the SEV technology is the remote attestation. Remote attestation is a process in which one side (the attester) collects information about itself and sends that information to the client (or the relying party) for the relying party to assess the trustworthiness of the attester. If the attester is deemed trustworthy, the relying party will send confidential code/data or any secrets to the attester. You can read more on the attestation process here.</p>"}]}